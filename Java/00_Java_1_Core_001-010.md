## 001.Java-components.md

ğŸ§° **JDK (Java Development Kit)**  
- â†’ First thing to install for Java development  
- â†’ Includes: `javac` (ğŸ›  compiler), `java` (ğŸš€ launcher), ğŸ“¦ JRE, and other tools  
- â†’ OS-specific builds available (Windows/Linux/Mac)  
- â†’ Needed for both compiling and running Java apps  

ğŸ” **JRE (Java Runtime Environment)**  
- â†’ Subset of JDK  
- â†’ Includes: JVM and runtime libraries  
- â†’ âš™ï¸ Used for running only (not compiling)  
- â†’ ğŸ“¦ Usually bundled with JDK  

ğŸ§  **JVM (Java Virtual Machine)**  
- â†’ ğŸš€ Launched using `java ClassName`  
- â†’ Reads `.class` (bytecode) â†’ converts to machine code  
- â†’ ğŸŒ Enables platform independence: compile on Windows, run on Linux  
- â†’ JVM is OS-specific, but bytecode is portable  

ğŸ›  **javac (Java Compiler)**  
- â†’ Converts `.java` â†’ `.class`  
- â†’ ğŸ“¦ Output is bytecode (not native machine code)  
- â†’ ğŸŒ Portable across platforms  

ğŸš€ **java (Java Command)**  
- â†’ Used to run `.class` files  
- â†’ Launches JVM â†’ interprets or JIT-compiles the bytecode  

ğŸ“¦ **Bytecode**  
- â†’ Output of compilation  
- â†’ Stored in `.class` files  
- â†’ Platform-independent, readable only by JVM  

âš¡ **JIT Compiler (Just-In-Time)**  
- â†’ Built into JVM  
- â†’ Converts bytecode â†’ machine code at runtime  
- â†’ ğŸ“ˆ Improves performance using inlining, caching, etc.  
- â†’ âœ… Enabled by default  

ğŸš« **Disabling JIT (for debugging)**  
- â†’ ğŸ”§ Use `-Djava.compiler=NONE` with the `java` command  
- â†’ ğŸ¢ JVM runs in interpreter-only mode (no JIT optimization)  

ğŸ“Œ **Execution Flow**  
- â†’ 1ï¸âƒ£ Write `.java`  
- â†’ 2ï¸âƒ£ Compile using `javac` â†’ generates `.class`  
- â†’ 3ï¸âƒ£ Run using `java` â†’ starts JVM  
- â†’ 4ï¸âƒ£ JVM loads `.class` â†’ JIT compiles â†’ executes on OS

## 002.Java-constructors.md
ğŸ§± **Constructors**
- â†’ A special method to initialize an object's properties upon creation.
- â†’ Must have the same name as the class it is in.
- â†’ Invoked only once when an object instance is created.

â†”ï¸ **Constructors vs. Methods**
- â†’ **Name:** Constructor name must match the class name; method names can be different.
- â†’ **Invocation:** Constructors are called automatically at object creation; methods must be called explicitly.
- â†’ **Frequency:** A constructor runs once per object; methods can be called any number of times.

ğŸ”„ **Constructor Chaining (Same Class)**
- â†’ Use `this()` to call another constructor within the same class.
- â†’ `this()` must be the very first statement inside the calling constructor.
```java
class Accord {
    Accord() {
        this("V6"); // Calls the parameterized constructor
        System.out.println("Default constructor called.");
    }

    Accord(String engine) {
        System.out.println("Engine type: " + engine);
    }
}
```

ğŸ”¼ **Invoking Superclass Constructor**
- â†’ Use `super()` to call the constructor of the parent (superclass).
- â†’ `super()` must be the very first statement in the child class's constructor.
```java
class Honda {
    Honda() {
        System.out.println("Honda constructor called.");
    }
}

class Accord extends Honda {
    Accord() {
        super(); // Calls the Honda() constructor
        System.out.println("Accord constructor called.");
    }
}
```
## 003.Java-abstract-vs-interface.md
ğŸ¨ **Abstract Class**
- â†’ A class that must be declared `abstract` if it includes at least one abstract method.
- â†’ If a class extends an abstract class, it must implement all its abstract methods or be declared abstract itself.
- â†’ Can contain a mix of methods with and without implementation.
```java
abstract class Shape {
    // Concrete method
    void draw() {
        System.out.println("Drawing a shape.");
    }
    // Abstract method
    abstract double getArea();
}
```

 blueprint **Interface**
- â†’ A contract where all methods are implicitly `public` and `abstract`.
- â†’ The class that `implements` the interface must provide implementations for all its methods.
```java
interface Rotatable {
    void rotate(); // public abstract by default
}
```

âš–ï¸ **Key Differences**
- â†’ **Inheritance:** A class can `extend` only one abstract class.
- â†’ **Implementation:** A class can `implement` multiple interfaces.
- â†’ **Methods:** Abstract classes can have implemented methods; interfaces traditionally cannot (before Java 8 `default` methods).
## 004.Java-multiple-inheritance.md
ğŸ’ **Multiple Inheritance**
- â†’ Java does not support extending more than one class (multiple inheritance) to avoid ambiguity.

ğŸ¤” **The Ambiguity Problem**
- â†’ If a class inherits from two parent classes that have methods with the same name and signature, the compiler doesn't know which one to use.
- â†’ This is often called the "Deadly Diamond of Death" or "Diamond Problem."
- â†’ Attempting to do this will result in a compile-time error.

```java
class Father {
    void money() {
        System.out.println("Father's money.");
    }
}

class Mother {
    void money() {
        System.out.println("Mother's money.");
    }
}

// This is not allowed in Java and will cause a compile error.
class ConfusedKid extends Father, Mother {
    public static void main(String[] args) {
        ConfusedKid kid = new ConfusedKid();
        kid.money(); // Which one to call? Father's or Mother's?
    }
}
```

ğŸ’ **The Diamond Problem**
- â†’ A more complex version of the ambiguity problem.
- â†’ It occurs when a class `D` inherits from two classes `B` and `C`, and both `B` and `C` inherit from a single class `A`.
- â†’ If `A` has a method that `B` and `C` override, `D` has an ambiguous choice of which overridden method to inherit.
## 005.Java-interfaces-same-method.md
ğŸ¤ **Implementing Interfaces with Same Method**
- â†’ A class can implement two or more interfaces that have methods with the exact same signature.
- â†’ This does not cause the "Diamond Problem" seen with multiple inheritance of classes.
- â†’ The implementing class simply provides a single implementation for the shared method, which satisfies the contract for all interfaces.

```java
interface Car {
    void go();
    void stop();
}

interface Driverless {
    void sitDownAndRelax();
    void go(); // Same method signature as in Car
}

class Honda implements Car, Driverless {
    // A single implementation for the go() method satisfies both interfaces.
    @Override
    public void go() {
        System.out.println("Honda is going.");
    }

    @Override
    public void stop() {
        System.out.println("Honda has stopped.");
    }

    @Override
    public void sitDownAndRelax() {
        System.out.println("Sit back and relax, the car is driving itself.");
    }
}
```
## 006.Java-object-class-methods.md
ğŸ“¦ **Object Class Methods**
- â†’ Every class in Java implicitly extends the `Object` class, inheriting its methods.

ğŸ”§ **Overridable Methods**
- â†’ **`equals(Object obj)`**: Compares two objects for equality. The default implementation checks for reference equality (`==`).
- â†’ **`hashCode()`**: Returns a hash code value for the object, used in hash-based collections like `HashMap`.
- â†’ **`toString()`**: Returns a string representation of the object. The default implementation prints the class name and hash code.
- â†’ **`clone()`**: Creates and returns a copy of the object (a shallow copy by default).
- â†’ **`finalize()`**: Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

ğŸ”’ **Non-Overridable Concurrency Methods**
- â†’ **`wait()`**: Causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` for this object.
- â†’ **`notify()`**: Wakes up a single thread that is waiting on this object's monitor.
- â†’ **`notifyAll()`**: Wakes up all threads that are waiting on this object's monitor.
## 007.Java-default-hashCode-implementation.md
ğŸ”¢ **Default hashCode() Implementation**
- â†’ If a class does not override the `hashCode()` method, it uses the default implementation from the `Object` class.
- â†’ This default implementation returns an integer that typically represents the object's memory address.
- â†’ Therefore, if you don't provide a custom `hashCode()` method, the value returned will be based on the memory location of that specific object.
## 008.Java-default-toString-implementation.md
ğŸ“œ **Default toString() Implementation**
- â†’ When you print an object of a class that hasn't overridden `toString()`, the default implementation from the `Object` class is used.
- â†’ This default method returns a string with the following format: `ClassName@HexadecimalHashCode`.
- â†’ The part after the `@` symbol is the hexadecimal representation of the object's hash code, which is typically derived from its memory address.
- â†’ If you override `toString()`, the custom implementation you provide will be used instead.
## 009.Java-equals-vs-double-equals.md
âš–ï¸ **`equals()` Method vs. `==` Operator**
- â†’ A common source of confusion when comparing objects in Java.

ğŸ‘¬ **`==` Operator (Reference Comparison)**
- â†’ Compares the memory addresses (references) of two objects.
- â†’ Returns `true` only if both references point to the exact same object in memory.
- â†’ It performs a "shallow comparison."
```java
User u1 = new User(1, "John");
User u2 = new User(1, "John");
// Returns false because u1 and u2 are different objects in memory.
boolean result = (u1 == u2);
```

ğŸ¤ **`equals()` Method (Content Comparison)**
- â†’ **Default Behavior:** The default `equals()` method from the `Object` class behaves exactly like the `==` operator, comparing memory references.
```java
// By default, this also returns false.
boolean result = u1.equals(u2);
```
- â†’ **Overridden Behavior:** To compare the actual content of objects (a "deep comparison"), you must override the `equals()` method in your class.
```java
class User {
    // ... fields and constructor ...
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        User user = (User) obj;
        return id == user.id && name.equals(user.name);
    }
}
// Now, u1.equals(u2) will return true.
```

âœ¨ **Special Cases: String, Wrappers, Enums**
- â†’ For `String`, wrapper types (`Integer`, `Double`, etc.), and `Enums`, the `equals()` method is already overridden to perform a deep content comparison.
```java
String s1 = new String("abc");
String s2 = new String("abc");

// false: s1 and s2 are different objects.
s1 == s2;

// true: The content is the same.
s1.equals(s2);
```

ğŸ“Œ **Summary**
- â†’ Use `==` to check if two references point to the same object.
- â†’ Use `equals()` to check if two objects are meaningfully equivalent.
- â†’ Always override `equals()` (and `hashCode()`) in your own classes for proper content comparison.
## 010.Java-final-finally-finalize.md
ğŸ”‘ **`final` Keyword**
- â†’ A modifier that can be applied to variables, methods, and classes.
- â†’ **Variables:** Makes the variable a constant. Its value cannot be changed once assigned.
- â†’ **Object References:** The reference variable cannot be reassigned to a new object, but the state of the object itself can be changed.
- â†’ **Methods:** Prevents the method from being overridden by subclasses.
- â†’ **Classes:** Prevents the class from being extended (inherited).

ğŸ§¹ **`finally` Block**
- â†’ Used in `try-catch` blocks for exception handling.
- â†’ The code inside a `finally` block is always executed, whether an exception is thrown or not.
- â†’ Ideal for cleanup code, like closing database connections, file streams, or network sockets.
- â†’ **Note:** Since Java 7, `try-with-resources` is the preferred way to handle resources that need closing, as it does so automatically.

ğŸ—‘ï¸ **`finalize()` Method**
- â†’ A method of the `Object` class that is called by the Garbage Collector (GC) just before an object is destroyed.
- â†’ Its purpose is to perform cleanup activities, but its execution is not guaranteed.
- â†’ We never know when the GC will run, so `finalize()` should not be relied upon for critical cleanup tasks.